model LevelCrossing {

	class SUS {
		public composite gate[1-1] : Gate;
		public composite trackCircuitEntrance[1-1] : TrackCircuit;
		public composite trackCircuitApproach[1-1] : TrackCircuit;
		public composite trackCircuitExit[1-1] : TrackCircuit;
		public composite controller[1-1] : Controller;
		public composite roadSign[1-1] : RoadSign;
		public composite train[1-1] : Train;
		connector "" : Controller_Gate between gate and controller;
		connector "" : Controller_TrackCircuitEntrance between controller and trackCircuitEntrance;
		connector "" : Controller_TrackCircuitApproach between controller and trackCircuitApproach;
		connector "" : Controller_TrackCircuitExit between controller and trackCircuitExit;
		connector "" : Controller_RoadSign between roadSign and controller;
		connector "" : Train_TrackCircuitEntrance between train and trackCircuitEntrance;
		connector "" : Train_TrackCircuitApproach between train and trackCircuitApproach;
		connector "" : Train_TrackCircuitExit between train and trackCircuitExit;
	}

	signal entranceBeginDetection;
	signalEvent entranceBeginDetectionSE of entranceBeginDetection;
	signal entranceEndDetection;
	signalEvent entranceEndDetectionSE of entranceEndDetection;
	interface IEntranceConsumer receives entranceBeginDetection(entranceBeginDetection), entranceEndDetection(entranceEndDetection) {}

	signal approachBeginDetection;
	signalEvent approachBeginDetectionSE of approachBeginDetection;
	signal approachEndDetection;
	signalEvent approachEndDetectionSE of approachEndDetection;
	interface IApproachConsumer receives approachBeginDetection(approachBeginDetection), approachEndDetection(approachEndDetection) {}

	signal exitBeginDetection;
	signalEvent exitBeginDetectionSE of exitBeginDetection;
	signal exitEndDetection;
	signalEvent exitEndDetectionSE of exitEndDetection;
	interface IExitConsumer receives exitBeginDetection(exitBeginDetection), exitEndDetection(exitEndDetection) {}

	signal switchOn;
	signalEvent switchOnSE of switchOn;
	signal switchOff;
	signalEvent switchOffSE of switchOff;
	interface IRoadSignConsumer receives switchOn(switchOn), switchOff(switchOff) {}

	signal open;
	signalEvent openSE of open;
	signal close;
	signalEvent closeSE of close;
	interface IGateConsumer receives open(open), close(close) {}


	association Controller_RoadSign {}
	association Controller_TrackCircuitEntrance {}
	association Controller_TrackCircuitApproach {}
	association Controller_TrackCircuitExit {}
	association Controller_Gate {}
	association Train_TrackCircuitEntrance {
		train[1-1] : Train in Train_TrackCircuitEntrance;
	}
	association Train_TrackCircuitApproach {
		train[1-1] : Train in Train_TrackCircuitApproach;
	}
	association Train_TrackCircuitExit {
		train[1-1] : Train in Train_TrackCircuitExit;
	}


	class |Train| behavesAs SM {
		trackCircuitEntrance[1-1] : TrackCircuit in Train_TrackCircuitEntrance;
		trackCircuitApproach[1-1] : TrackCircuit in Train_TrackCircuitApproach;
		trackCircuitExit[1-1] : TrackCircuit in Train_TrackCircuitExit;

		stateMachine SM {
			region R {
				Initial -> Idle;
				Idle -> EntranceDetection : / 
						opaqueBehavior = 'send entranceBeginDetection to trackCircuitEntrance;' in ABCD;;
				EntranceDetection -> WaitApproachDetection : /
						opaqueBehavior = 'send entranceEndDetection to trackCircuitEntrance;' in ABCD;;
				WaitApproachDetection -> ApproachDetection : /
						opaqueBehavior = 'send approachBeginDetection to trackCircuitApproach;' in ABCD;;
				ApproachDetection -> WaitExitDetection : /
						opaqueBehavior = 'send approachEndDetection to trackCircuitApproach;' in ABCD;;
				WaitExitDetection -> ExitDetection : /
						opaqueBehavior = 'send exitBeginDetection to trackCircuitExit;' in ABCD;;
				ExitDetection -> Done : /
						opaqueBehavior = 'send exitEndDetection to trackCircuitExit;' in ABCD;;
				initial pseudoState Initial;
			}
		}
	}

	class |TrackCircuit| behavesAs SM implements IEntranceConsumer, IApproachConsumer, IExitConsumer {
		controller[1-1] : Controller in Controller_TrackCircuitEntrance;
		controller[1-1] : Controller in Controller_TrackCircuitApproach;
		controller[1-1] : Controller in Controller_TrackCircuitExit;

		stateMachine SM {
			region R {
				Initial -> NoDetection;
				NoDetection -> Detection : entranceBeginDetectionSE /
						opaqueBehavior = 'send entranceBeginDetection to controller;' in ABCD;;
				NoDetection -> Detection : approachBeginDetectionSE /
						opaqueBehavior = 'send approachBeginDetection to controller;' in ABCD;;
				NoDetection -> Detection : exitBeginDetectionSE /
						opaqueBehavior = 'send exitBeginDetection to controller;' in ABCD;;
				
				Detection -> NoDetection : entranceEndDetectionSE /
						opaqueBehavior = 'send entranceEndDetection to controller;' in ABCD;;
				Detection -> NoDetection : approachEndDetectionSE /
						opaqueBehavior = 'send approachEndDetection to controller;' in ABCD;;
				Detection -> NoDetection : exitEndDetectionSE /
						opaqueBehavior = 'send exitEndDetection to controller;' in ABCD;;
				initial pseudoState Initial;
			}
		}
	}

	class |Controller| behavesAs SM implements IEntranceConsumer, IApproachConsumer, IExitConsumer {
		gate[1-1] : Gate in Controller_Gate;
		trackCircuitEntrance[1-1] : TrackCircuit in Controller_TrackCircuitEntrance;
		trackCircuitApproach[1-1] : TrackCircuit in Controller_TrackCircuitApproach;
		trackCircuitExit[1-1] : TrackCircuit in Controller_TrackCircuitExit;
		roadSign[1-1] : RoadSign in Controller_RoadSign;

		stateMachine SM {
			region R {
				Initial -> Idle;
				Idle -> TrainDetected : entranceBeginDetectionSE /
						opaqueBehavior = 'send switchOn to roadSign;' in ABCD;;
				TrainDetected -> Approach : approachBeginDetectionSE /
						opaqueBehavior = 'send close to gate;' in ABCD;;
				Approach -> Passing : approachEndDetectionSE /;
				Passing -> WaitEndPassing : exitBeginDetectionSE /
						opaqueBehavior = 'send open to gate;' in ABCD;;
				WaitEndPassing -> Idle : exitEndDetectionSE /
						opaqueBehavior = 'send switchOff to roadSign;' in ABCD;;
				initial pseudoState Initial;
			}
		}
	}



	class |RoadSign| behavesAs SM implements IRoadSignConsumer {
		controller[1-1] : Controller in Controller_RoadSign;
		stateMachine SM {
			region R {
				Initial -> Inactive;
				Inactive -> Active : switchOnSE /;
				Active -> Inactive : switchOffSE /;
				initial pseudoState Initial;
			}
		}
	}

	class |Gate| behavesAs SM implements IGateConsumer {
		controller[1-1] : Controller in Controller_Gate;
		stateMachine SM {
			region R {
				Initial -> Opened;
				Opened -> Closed : closeSE /;
				Closed -> Opened : openSE /;
				initial pseudoState Initial;
			}
		}
	}

}
